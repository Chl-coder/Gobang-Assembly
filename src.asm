DATA SEGMENT
	CHESSBOARD DB 218,13 DUP(194),191,13 DUP(195,13 DUP(197),180),192,13 DUP(193),217 	;设置棋盘的缓冲区
	X DB 0										;落子坐标 x
	Y DB 0                                                        						;落子坐标 y
	MY DB 1										;我的坐标是1，对方的坐标是2
	FLAG DB 0									;判断是否可以落子的标记，1为可以，0为不可以
	STATE DB 0									;目前的状态，单机：0为游戏进行中，2为一方退出；3为一方获胜
											;0该我下，1我已经下完，等待接受X；2等待接受Y；4对方获胜，5对方退出
	OVER DB 0									;判断是否比赛结束，CALL ISWIN 0为没有结束，1为结束。结束时，最后落子方获胜
	LED DB 3FH,06H,5BH,4FH,66H,6DH,7DH,07H,7FH,6FH     					;七段数码管对应显示
    S1 DB 0                             									;用于保存输入坐标值x
    S2 DB 0										;用于保存输入坐标值y
    TEMP DB 0                          	 								;单机时判断该下黑子还是白子
    ORDER DB 1                          								;双机时标志先手or后手，1表示先手，2表示后手
    TI DB ' 1 2 3 4 5 6 7 8 9 A B C D E F',0AH,0DH,'$'						;棋盘的y坐标
    ERROR DB 'YOU CANNOT PUT HERE!',0AH,0DH,'$' 						;报错,"你不能放在这里"
    WRONG DB 0AH,0DH,'FALSE INPUT!',0AH,0DH,'$'						;错误信息的提示
    COLOR DB 0AH,0DH,'PLEASE CHOOSE YOUR CHESSMAN COLOR:(1 FOR BLACK, 2 FOR WHITE)',0AH,0DH,'$'	;选棋子的颜色，1是黑色，2是白色
    CLEAN DB 72 DUP(32),0AH,0DH,72 DUP(32),0AH,0DH,72 DUP(32),0AH,0DH,72 DUP(32),0AH,0DH,72 DUP(32),0AH,0DH,72 DUP(32),0AH,0DH,72 DUP(32),0AH,0DH,72 DUP(32),0AH,0DH,'$';更新棋盘
    PUT DB 'PLEASE INPUT THE POSITION(X Y):',0AH,0DH,'$'						;请输入棋子的位置(x,y)
    GAMEEND DB 'ONE PLAYER HAS WIN!',0AH,0DH,'$'						;游戏结束信息提示
    CONGRA DB 'YOU WIN! CONGRATULATIONS!',0AH,0DH,'$'					;游戏提示信息,"恭喜!你赢了!"
    SORRY DB 'YOU LOSE! DONNOT GIVE UP!',0AH,0DH,'$'						;游戏提示信息,"对不起,你输了,不要放弃!"
    WAIT1 DB 'PLEASE WAIT...',0AH,0DH,'$'  							;进入等待信息提示 
    CHOOSE DB 'PLEASE CHOOSE GAME MODEL:(1 FOR ONE PLAYER, 2 FOR TWO PLAYERS, ESC TO QUIT)',0AH,0DH,'$'	;选择游戏的玩法
    EXIT DB 'ONE PLAYER HAS QUIT!',0AH,0DH,'$'							;一个玩家退出后播放音乐
             MUS_FREQ DW 330,392,262,294,330,196,262,294,330,392,294				;建立频率表MUS_FREQ和结拍时间表MUS_TIME
             DW 330,392,262,294,330,220,294,196,294,330,262
             DW 440,392,440,262,330,220,330,392,294
             DW 330,392,262,294,330,220,294,196,294,330,262
             DW -1										;音乐播放结束符
    MUS_TIME DW 2 DUP(2500),5000,2 DUP(2500),5000,4 DUP(2500),10000
             DW 2 DUP(2500),5000,2 DUP(2500),5000,4 DUP(2500),10000
             DW 4 DUP(5000),4 DUP(2500),10000
             DW 2 DUP(2500),5000,2 DUP(2500),5000,4 DUP(2500),10000
DATA ENDS
STACK SEGMENT STACK
	DW 128H DUP(0)									;初始化堆栈						
STACK ENDS
CODE SEGMENT
	ASSUME CS:CODE,DS:DATA,SS:STACK							;说明一个对应的关系，之后再把段的首地址赋值给段寄存器
START:
	MOV AX,DATA									;数据库装入段寄存器DS
	MOV DS,AX
    MOV AL,2
	MOV AH,0									;设置显示方式
	INT 10H
SELECT:                                 									;选择功能
    MOV DX,OFFSET CHOOSE                								;选择单机或双机游戏
	MOV AH,09H									;使用21H中断的设置光标位置功能
	INT 21H										;在屏幕上显示输入的内容
    MOV AH,1										;使用21H号中断的显示输入功能						
	INT 21H
	CMP AL,'1'                         								;1为单机
	JE GAME1									;选择1后，回到单机游戏
	CMP AL,'2'                          								;2为双机
	JZ MARK										;选择2后，进入积分
	CMP AL,27                           								;ESC退出
    JZ GEND0										;游戏结束
	MOV DX,OFFSET WRONG      								;输入错误给出提示，重新输入
	MOV AH,09H									;在屏幕上显示输入的内容
	INT 21H
	CALL BEEP									;调用播放音乐
	JMP SELECT									;回到选择功能
GEND0:
    MOV AH,4CH										;退出游戏
	INT 21H
;=========/*单机*/========
GAME1:	                               
	MOV AL,2									;在屏幕上显示输入的内容
	MOV AH,0
	INT 10H										;设置80*25黑白方式，清空屏幕
	CALL INITIAL									;初始化计数器
	CALL PRINT									;打印棋盘
	CALL SLED                           								;数码管显示当前状态
HERE1:
	MOV DX,OFFSET PUT								;放置棋子
	MOV AH,09H									;在屏幕上显示输入的内容
	INT 21H
	MOV AH,1									;若输入的是ESC则退出
	INT 21H
	CMP AL,27									;若输入的是ESC
	JE QUIT										;退出游戏
	JMP RXY1									;否则输入坐标X Y
QUIT:											;退出游戏的信息
	MOV STATE,2									;把STATE的值设为2
	MOV DX,OFFSET EXIT								;有人退出就显示退出消息
	MOV AH,09H									;使用21H号中断的显示输入功能
	INT 21H 
	CALL SLED									;数码管显示当前状态
	JMP GEND1									;游戏结束
MARK:
    JMP GAME2										;进行下一局游戏
RXY1:											;记录坐标X Y(ASCII码)
	MOV X,AL									;记录x的坐标
	INT 21H										;显示在屏幕上x的值
	CMP AL,27									;若是ESC则退出
	JE QUIT										;退出记录坐标x
	INT 21H										;显示在屏幕上y的值
	CMP AL,27									;若是ESC则退出
	JE QUIT										;退出记录坐标y
	MOV Y,AL									;记录y的坐标
N1:	MOV AH,07									;无回显输入
	INT 21H
	CMP AL,27									;若是ESC则退出
	JE QUIT										;退出游戏
	CMP AL,13									;若是回车则继续，否则等待回车
	JNE N1										;继续执行N1程序
	MOV AH,2
	MOV DL,0AH									;显示光标的行坐标
	INT 21H										;输出回车换行
	MOV DL,0DH									;显示光标的列坐标
	INT 21H										;输出回车换行
	MOV FLAG,1									;flag的值为1
	CALL CHECK									;检查可否落子，将X，Y改变为真实的数值
	CMP FLAG,1									;可以落子
	JE THERE1									;可以落子则判断落子
	JMP HERE1									;如果不可以落子则重新输入
THERE1:
	MOV MY,1									;我的坐标是1，对方的坐标是2
	CALL PUTDOWN1									;落子v
	CALL ISWIN									;判断输赢，有结果则OVER=1
	CALL PRINT									;打印棋盘
	CMP OVER,1									;游戏结束																		
	JNZ HERE1
	MOV DX,OFFSET GAMEEND								;游戏结束的信息提示
    MOV AH,09H										;在屏幕上显示输入的内容
    INT 21H
    MOV AH,02H										;使用10H中断的设置位置功能																							
    MOV DL,00H										;设置光标的行坐标
    MOV DH,11H										;设置光标的列坐标
    INT 10H
    MOV STATE,3										;游戏结束我退出
    CALL SLED										;数码管显示当前状态
    CALL MUSIC										;播放音乐
GEND1:
	MOV AH,4CH									;退出游戏
	INT 21H
;=========/*双机*/========
GAME2:											;双机游戏
    MOV DX,OFFSET COLOR               								;选择先后手，1先手，2后手
    MOV AH,09H										;在屏幕上显示输入的内容
    INT 21H
    MOV AH,1										;游戏开始
	INT 21H
	CMP AL,'1'
	JE BLACK										;1为黑子
	CMP AL,'2'
	JZ WHITE										;2为白子
	CMP AL,27									;若输入的是ESC
    JZ GEND1										;则退出
	MOV DX,OFFSET WRONG								;显示错误的提示信息
	MOV AH,09H									;在屏幕上显示输入的内容
	INT 21H
	CALL BEEP									;播放提示音
	JMP GAME2									;游戏结束
WHITE:                               									;若执白后行，将我方棋子改为白MY=2，ORDER改为2
    MOV MY,2										;我的坐标是1，对方的坐标是2
    MOV STATE,1										;我已下完，正等待接收x
    MOV ORDER,2										;等待对方落子
BLACK:											;若执黑后行，将我方棋子改为白MY=1，ORDER改为1
	MOV AL,2
	MOV AH,0
	INT 10H										;设置80*25黑白方式，清空屏幕
	CALL INITIAL									;初始化计数器和通信
	CALL PRINT									;打印棋盘
	CALL SLED									;数码管显示当前状态
HERE2:
	CMP STATE,0									;根据STATE输出提示信息
	JE SHOW
	MOV DX,OFFSET WAIT1								;提示等待信息
	MOV AH,09H
	INT 21H										;若该我下(STATE=0)则继续，否则等待
	MOV AH,02H
	MOV DL,00H									;光标从17,0开始
	MOV DH,11H									;光标的列坐标
	INT 10H
	CALL SLED									;数码管显示当前状态
WW:
	CMP STATE,0									;根据STATE输出提示信息
	JE SHOW
	CMP STATE,4									;若对方退出或胜利，则跳出
	JE ILOSE										;我输了																		
	CMP STATE,5									;若state的值为5
	JE HQUIT										;他退出
	JMP WW
SHOW:
	MOV DX,OFFSET PUT								;提示落子信息
	MOV AH,09H									;在屏幕上显示输入的内容
	INT 21H
    CALL SLED										;数码管显示当前状态
	MOV AH,1									;若输入的是ESC则退出
	INT 21H
	CMP AL,27									;若输入的是ESC
	JE IQUIT										;我退出
	JMP RXY2									;否则输入坐标X Y
ILOSE:											;我输了的提示信息
	MOV DX,OFFSET SORRY								;提示抱歉信息
	MOV AH,09H									;在屏幕上显示输入的内容
	INT 21H
	CALL SLED									;数码管显示当前状态
	CALL MUSIC									;调用播放音乐
	JMP GEND2									;游戏结束信息提示
IQUIT:											;提示我退出的信息
	CALL SENDQ									;我退出就给对方发信息
	MOV STATE,3									;对方已获胜
HQUIT:											;提示对方退出的信息
	MOV DX,OFFSET EXIT								;有人退出就显示退出消息
	MOV AH,09H									;在屏幕上显示对方退出的信息
	INT 21H
	CALL SLED									;数码管显示当前状态
	JMP GEND2									;游戏结束信息提示
RXY2:											;记录坐标X Y(ASCII码)
	MOV X,AL									;显示x的坐标在屏幕上					
	INT 21H
	CMP AL,27									;若是ESC则退出
	JE IQUIT										;我退出
	INT 21H
	CMP AL,27									;若是ESC则退出
	JE IQUIT										;我退出
	MOV Y,AL									;显示y的坐标在屏幕上
N2:	MOV AH,07									;无回显输入
	INT 21H
	CMP AL,27									;若是ESC则退出
	JE IQUIT										;则是我退出
	CMP AL,13									;若是回车则继续，否则等待回车
	JNE N2										;再回到N2
	MOV AH,2
	MOV DL,0AH									;输出回车换行
	INT 21H
	MOV DL,0DH									;光标的行坐标
	INT 21H										;输出回车换行
    mov AL,X                            			                                         				;保存输入的坐标值x用于以后发送
    mov S1,AL																								
    mov AL,Y										;保存输入的坐标值y用于以后发送
    mov S2,AL																															
	MOV FLAG,1									;可以落子
	CALL CHECK									;检查可否落子
	CMP FLAG,1									;flag=1，可以落子
	JE THERE2									;可以落子则判断落子
	JMP HERE2									;如果不可以落子则重新输入
THERE2:
    CMP ORDER,2										;选择后手落子
    JZ L2
L1:
 	MOV MY,1									;我的坐标是1，对方的坐标是2
 	JMP L3
L2: 
    MOV MY,2										;我的坐标是2，对方坐标是1
L3:
	CALL PUTDOWN2									;落子
	CALL ISWIN									;判断输赢，有结果则OVER=1
	CALL PRINT									;打印棋盘
    mov AL,S1																								
    mov X,AL										;保存输入的坐标值x用于以后发送
    mov AL,S2
    mov Y,AL        										;保存输入的坐标值y用于以后发送                                                
	CALL SEND									;并发送坐标
	CMP OVER,1									;落子结束
	JE IWIN										;跳转到IWIN子程序
	MOV STATE,1									;将STATE置1，表示我已下完，等待对方的X
	CALL SLED									;数码管显示当前状态
	JMP HERE2
IWIN:											;我赢了则显示祝贺信息并播放音乐
	MOV DX,OFFSET CONGRA								;祝贺信息显示
	MOV AH,09H									;在屏幕上显示输入的内容
	INT 21H
	MOV AH,02H
	MOV DL,00H									;光标从16,0开始
	MOV DH,10H									;光标的列坐标
	INT 10H										;屏幕上显示我胜利的信息
	MOV STATE,2									;我赢了
	CALL SLED									;数码管显示当前状态													
	CALL MUSIC									;播放音乐
GEND2:
	MOV AH,4CH									;退出游戏
	INT 21H
;=========/*数码管显示子程序*/========
SLED PROC NEAR										;数码管显示状态，0表示该我下，1表示等待对方下，2我赢了，3我退出，4对方赢了，5对方退出
	PUSH AX										;保存CPU现场
	PUSH BX
	PUSH DX
    MOV DX,0D413H
	MOV AL,80H									;设置8255方式0，A口输出
	OUT DX,AL
	MOV AL,STATE									;state的值
	MOV BX,OFFSET LED
	XLAT										;数码管根据STATE输出数字
    MOV DX,0D410H
	OUT DX,AL
	POP DX										;恢复CPU现场
	POP BX
	POP AX
	RET										;子程序结束返回
SLED ENDP
;=========/*初始化子程序*/========
INITIAL PROC NEAR										;计数器信息的提示
    MOV AX, CS
    MOV DS, AX
    MOV DX, OFFSET IRQ11                								; DS中断服务程序段地址、DX为偏移量
    MOV AX, 2573H                       								; AH=25H置中断向量
    INT 21H
    CLI
    MOV DX, 0D84CH                      								; PCI9052 中断状态、控制寄存器地址低位
    MOV AL, 43H                         								; 最低为1，开中断
    OUT DX, AL
    INC DX                              									; PCI9052 中断状态、控制寄存器地址高位
    MOV AL, 1DH                        					 			; 清除可能的中断状态
    OUT DX, AL        
    IN AL, 0A1H                         								; 从片                                                    
    AND AL, 11110111B                   								; 开放IRQ11中断
    OUT 0A1H,AL
    IN AL, 21H                          									;总片
    AND AL, 11111011B 
    OUT 21H, AL
    STI       
	MOV AL,00010110B	                						;初始化8253通道0，工作方式3，二进制
	MOV DX,0D403H
	OUT DX,AL
	MOV DX,0D400H
	MOV AL,52			               						;计数初值52
	OUT DX,AL			           
	MOV AX,DATA
	MOV DS,AX
	MOV DX,0D409H									;8251A控制口地址
	MOV AL,0
	OUT DX,AL
	OUT DX,AL
	OUT DX,AL
	MOV AL,40H									;写操作命令字，内部复位
	OUT DX,AL
	MOV AL,4EH									;方式字：异步，1位停止位，8位数据位，无奇偶校验，波特率16
	OUT DX,AL
	MOV AL,27H									;命令字：请求发送，运行发送和接收，数据终端准备好，发间断字符
	OUT DX,AL							
	RET										;子程序结束返回
INITIAL ENDP
;=========/*检验落子位置是否合法*/========
CHECK PROC NEAR										;落子位置是否合法的检查信息 
	PUSH AX										;保存CPU现场
	PUSH BX
	PUSH CX
	PUSH DX
    CMP X,'a'										;输出大于a，合法
	JL CMPDX									;则进行数字判断
	CMP X,'f'                           								;若输出大于f，不合法
	JG ERR										;报错信息
	SUB X,39 
	JMP CMPDY
CMPDX:											;X的数字判断
	CMP X,'1'                           								;输入小于1，不合法
	JL ERR										;报错信息
	CMP X,'9'										;输入小于9，不合法
	JG ERR										;报错信息
CMPDY:                                  									;输入X合法，比较Y
    CMP Y,'A'										;输入小于A，合法
	JL CMPDY1									;则进行数字判断 
	CMP Y,'F'										;输入大于F，不合法
	JG ERR 										;报错信息
	SUB Y,7
	JMP SUBXY
CMPDY1:											;Y的数字判断
    CMP Y,'1'										;输入小于1，不合法
	JL ERR										;不合法
	CMP Y,'9'										;输入小于9，不合法
	JG ERR										;不合法
SUBXY:
    SUB X,'1'                            									;将X改变为真实的值
	SUB Y,'1'										;将Y改变为真实的值
	MOV CX,0									;传送指令
	MOV CL,X
	MOV BX,0									;清空寄存器
MULX1: 
    ADD BL,15										;棋子右移15单位
    LOOP MULX1										;循环MULX1
	ADD BL,Y										;棋子右移输入Y的值
	CMP CHESSBOARD[BX],1                 							;若此处已有棋子，输入不合法
	JE ERR							;
	CMP CHESSBOARD[BX],2								;若此处没有棋子，输入合法
	JNE RETURNC 
ERR:
    MOV FLAG,0                           								;对于不合法的输入，显示错误信息，并鸣响扬声器
	MOV DX,OFFSET ERROR
	MOV AH,09H									;在屏幕上显示输入错误的信息
    INT 21H
	CALL BEEP									;播放音乐
RETURNC:
    POP DX										;恢复CPU现场
    POP CX
    POP BX
    POP AX
	RET										;子程序结束返回
CHECK ENDP
;=========/*单机落子子程序*/========
PUTDOWN1 PROC NEAR									;单机落子的信息提示					
	PUSH AX										;保存CPU现场
	PUSH BX
	PUSH CX
	PUSH DX
	MOV CX,0									;字符指针初始化
	MOV CL,X
	MOV BX,0									;清空寄存器
MULX2: 
	ADD BL,15									;字符指针右移15个字节
	LOOP MULX2									;循环MULX2
	ADD BL,Y										;字符指针右移Y个字节
	CMP TEMP,0                         	 							;根据TEMP值，轮流放置黑子和白子
	JE MM1
	MOV CHESSBOARD[BX],2								;此处没有棋子
	MOV TEMP,0									;根据TEMP值，轮流放置黑子和白子
	JMP YY1
MM1:	
    MOV CHESSBOARD[BX],1									;此处已有棋子
    MOV TEMP,1										;根据TEMP值，轮流放置黑子和白子
YY1:	
    POP DX										;恢复CPU现场	
	POP CX
	POP BX
	POP AX
	RET										;子程序结束返回
PUTDOWN1 ENDP
;=========/*双机落子子程序*/========
PUTDOWN2 PROC NEAR									;双机落子的信息提示				
	PUSH AX										;保存CPU现场
	PUSH BX
	PUSH CX
	PUSH DX
	MOV CX,0									;字符指针初始化
	MOV CL,X	
	MOV BX,0									;清空寄存器
MULX4: 
	ADD BL,15									;字符指针右移15个字节
	LOOP MULX4									;循环MULX4
	ADD BL,Y										;字符指针右移Y个字节
	CMP MY,1									;我的坐标是1，对方的坐标是2
	JE MM2
	MOV CHESSBOARD[BX],2								;此处没有棋子
	JMP YY2										;返回调用处
MM2:													
    MOV CHESSBOARD[BX],1									;此处已有棋子
YY2:														
	POP DX										;恢复CPU现场
	POP CX
	POP BX
	POP AX
	RET
PUTDOWN2 ENDP
;=========/*判断是否获胜*/========
ISWIN PROC NEAR										;我获胜的信息提示
    MOV X,0										;初始化X和Y
    MOV Y,0
LOOPY:
    MOV CX,0										;字符指针初始化
	MOV CL,X
	MOV BX,0									;清空寄存器
MULX3: 
    ADD BL,15										;字符指针右移15个字节
	LOOP MULX3									;循环MULX3
	ADD BL,Y                           								;BX=15*X+Y
	MOV DL,CHESSBOARD[BX]               																	
	CMP ORDER,2                         								;根据执黑或执白判断自己是否获胜
	JZ L4
	CMP DL,1										;判断黑子是否可以落子
	JE PANDUAN									;判断黑子是否可以连成5个
	JMP NEXT									;进入下一轮判断
L4:
	CMP DL,2										;判断白子是否可以落子
    JE PANDUAN										;判断白子是否连成5个
	JMP NEXT 									;进入下一轮判断
PANDUAN: 										;游戏胜利的判断
    CALL TEST1                          								;横着
	CMP OVER,1									;横着连成5个游戏结束
	JE RETURNISWIN									;返回胜利的判断
	CALL TEST2                         								;竖着
    CMP OVER,1										;竖着连成5个游戏结束
	JE RETURNISWIN									;返回胜利的判断
	CALL TEST3                          								;斜上
	CMP OVER,1									;斜上连成5个游戏结束
	JE RETURNISWIN									;返回胜利的判断
	CALL TEST4                          								;斜下
    CMP OVER,1										;斜下连成5个游戏结束
	JE RETURNISWIN									;返回胜利的判断
NEXT: 
    INC Y											;Y的字符指针右移
	CMP Y,15										;比较Y的值
	JNE LOOPY
	MOV Y,0										;初始化Y的值
	INC X										;X的字符指针右移
	CMP X,15										;比较X的值
	JNE LOOPY
RETURNISWIN:
    RET											;子程序结束返回
ISWIN ENDP
;=========/*判断横向是否连成5个*/========
TEST1 PROC NEAR										;横向判断子程序
    PUSH BX										;保存cpu现场
    CMP Y,10	 									;判断横向是否有10个字节
    JG RETURN1										;若小于则横向不能连成5个
    CMP DL,CHESSBOARD[BX+1]								;判断棋盘横向是否有2个棋子连在一起
    JNE RETURN1
    CMP DL,CHESSBOARD[BX+2]								;判断棋盘横向是否有3个棋子连在一起
    JNE RETURN1 
    CMP DL,CHESSBOARD[BX+3]								;判断棋盘横向是否有4个棋子连在一起
    JNE RETURN1
    CMP DL,CHESSBOARD[BX+4]								;判断棋盘横向是否有5个棋子连在一起
    JNE RETURN1
    MOV OVER,1										;游戏结束
RETURN1: 
    POP BX										;恢复cpu现场
    RET											;子程序结束返回
TEST1 ENDP
;=========/*判断纵向是否连成5个*/========
TEST2 PROC NEAR										;纵向判断子程序
   PUSH BX										;保存cpu现场
   CMP X,10										;判断纵向是否有10个字节
   JG RETURN2										;若小于则纵向不能连成5个
   CMP DL,CHESSBOARD[BX+15]								;判断棋盘纵向是否有2个棋子连在一起
   JNE RETURN2
   CMP DL,CHESSBOARD[BX+30]								;判断棋盘纵向是否有3个棋子连在一起
   JNE RETURN2
   CMP DL,CHESSBOARD[BX+45]								;判断棋盘纵向是否有4个棋子连在一起
   JNE RETURN2
   CMP DL,CHESSBOARD[BX+60]								;判断棋盘纵向是否有5个棋子连在一起
   JNE RETURN2
   MOV OVER,1   										;游戏结束
RETURN2: 
   POP BX
   RET											;子程序结束返回
TEST2 ENDP
;=========/*判断斜上是否连成5个*/========
TEST3 PROC NEAR										;斜上判断子程序
   PUSH BX										;保存cpu现场
   CMP X,4		      								;判断纵向是否有4个字节                  																	
   JL RETURN3										;若小于则斜上不能连成5个
   CMP Y,10										;判断横向是否有10个字节
   JG RETURN3
   CMP DL,CHESSBOARD[BX-14]								;判断棋盘斜上是否有2个棋子连在一起
   JNE RETURN3
   CMP DL,CHESSBOARD[BX-28]								;判断棋盘斜上是否有3个棋子连在一起
   JNE RETURN3
   CMP DL,CHESSBOARD[BX-42]								;判断棋盘斜上是否有4个棋子连在一起
   JNE RETURN3
   CMP DL,CHESSBOARD[BX-56]								;判断棋盘斜上是否有5个棋子连在一起
   JNE RETURN3
   MOV OVER,1   										;游戏结束
RETURN3: 
   POP BX
   RET											;子程序结束返回
TEST3 ENDP
;=========/*判断斜下是否连成5个*/========
TEST4 PROC NEAR										;斜下判断子程序
   PUSH BX										;保存cpu现场
   CMP X,10										;判断纵向是否有10个字节
   JG RETURN4										;若小于则斜下不能连成5个
   CMP Y,10										;判断横向是否有10个字节
   JG RETURN4         									;若小于则斜下不能连成5个  ;不能斜下
   CMP DL,CHESSBOARD[BX+16]								;判断棋盘斜下是否有2个棋子连在一起 
   JNE RETURN4
   CMP DL,CHESSBOARD[BX+32]								;判断棋盘斜下是否有3个棋子连在一起
   JNE RETURN4
   CMP DL,CHESSBOARD[BX+48]								;判断棋盘斜下是否有4个棋子连在一起
   JNE RETURN4
   CMP DL,CHESSBOARD[BX+64]								;判断棋盘斜下是否有5个棋子连在一起
	JNE RETURN4
	MOV OVER,1   									;游戏结束																		
RETURN4: 
   POP BX
   RET											;子程序结束返回
TEST4 ENDP 	 
;=========/*打印棋盘*/========
PRINT PROC NEAR										;打印棋盘
	PUSH SI
	PUSH AX										;保存CPU现场
	PUSH DX
	MOV AH,02H									;使用10H中断的设置光标位置功能
	MOV DL,00H									;光标从0,0开始
    MOV DH,00H										;光标的列坐标
    INT 10H	
    MOV DX,OFFSET TI									;指定字符串  
    MOV AH,09H										;屏幕显示字符串
    INT 21H
	MOV X,0										;初始化X Y SI
	MOV Y,0
	MOV SI,0
LOOP2: 
    CMP Y,0										;判断Y是否为0
    JNE NOTHEAD
    MOV DL,X
    ADD DL,31H										;X的字符指针右移
	CMP DL,'9'									;判断X是否大于等于9
	JLE PP
	ADD DL,39									;X的字符指针右移39个字节 
PP:
    MOV AH,02H
    INT 21H										;使用21H中断的输出字符功能
NOTHEAD:
    MOV DL,CHESSBOARD[SI]
    MOV AH,02H
	INT 21H
	INC SI										;SI、Y指针同时右移1个字节，指向下一个字符
	INC Y										;SI、Y指针同时右移1个字节，指向下一个字符
	CMP Y,15										;判断Y的大小
	JE NEXTLINE
	MOV DL,'-'									;输出一个'-'
	MOV AH,02H									;使用21H中断的输出字符功能
	INT 21H
	JMP LOOP2									;回到循环2
NEXTLINE:
    MOV DL,32
    MOV AH,02H
	INT 21H
	MOV DL,0AH									;输出一个回车符（0AH）
	MOV AH,02H									;使用21H中断的输出字符功能
	INT 21H
	MOV DL,0DH									;输出一个换行符（0AD）
	MOV AH,02H									;使用21H中断的输出字符功能
	INT 21H
    INC X											;X的字符指针右移1个字节
	MOV Y,0										;初始化Y
    CMP X,15
	JNE LOOP2
    MOV DX,OFFSET CLEAN									;更新屏幕的信息提示
    MOV AH,09H										;使用21H中断的显示字符串功能
    INT 21H
    MOV AH,02H										;使用10H中断的设置光标位置功能
	MOV DL,00H									;光标从0,17开始
    MOV DH,10H										;设置光标的列坐标
	INT 10H
	POP DX										;恢复CPU现场
	POP AX
	POP SI
	RET										;子程序结束返回
PRINT ENDP 
;=========/*鸣响扬声器*/========
BEEP PROC NEAR										;鸣响扬声器子程序
        PUSH CX										;保存cpu现场
        MOV AL,10110110B									;计数器2、写低高、方式3、二进制
        OUT 43H,AL										;写入控制字
        MOV AX,1000
        OUT 42H,AL										;写入低8位计数值
        MOV AL,AH
        OUT 42H,AL										;写入高8位计数值
        MOV AL,AH
        OUT 42H,AL
        MOV AL,AH
        OUT 42H,AL
        IN AL,61H										;PB的端口地址
        MOV AH,AL
        OR AL,03H										;表示打开扬声器只有PB0PB1同时为高电平 扬声器才能发声
        OUT 61H,AL										;直接控制发声
        MOV CX,0										;初始化字符指针
L0:     LOOP L0
        DEC BL										;字符指针左移1个字节
        JNZ L0
        MOV AL,AH
        OUT 61H,AL										;关闭发声
        POP CX										;恢复cpu现场
        RET											;子程序结束返回
BEEP ENDP
;=========/*播放音乐*/========
MUSIC PROC NEAR										;播放音乐子程序
        MOV AX,DATA
        MOV DS,AX
        LEA SI,MUS_FREQ									;将频率表偏移地址送SI
        LEA BP,MUS_TIME									;将节拍时间表偏移地址送BP
FREQ:
        MOV DI,[SI]										;将频率值送人DI
        CMP DI,-1
        JE END_MUS
        MOV BX,DS:[BP]									;取节拍时间送入BX
        CALL SOUND										;调用SOUND子程序发出声调
        ADD SI,2
        ADD BP,2
        JMP FREQ
END_MUS:
		RET									;子程序结束返回
MUSIC ENDP

SOUND PROC NEAR									;播放声音的信息	
        PUSH AX										;保存CPU现场
        PUSH BX
        PUSH CX
        PUSH DX
        PUSH DI
        MOV AL,0B6H										;初始化8253，使其计数器产生方波信号
        OUT 43H,AL										;43H是8253控制寄存器的端口地址
        MOV DX,12H										;设置被除数
        MOV AX,34DCH									;DX:AX中的值设为1234DCH
        DIV DI										;其商（AX）为预置值
        OUT 42H,AL										;先送LSB
        MOV AL,AH
        OUT 42H,AL										;后送MSB
        IN AL,61H										;读8255端口B（61H）原值
        MOV AH,AL										;保存端口原值
        OR AL,3										;开扬声器
        OUT 61H,AL										;接通扬声器
DELAY:  MOV CX,0BBBBH									;在80486/DX2/66中取
DL10MS: LOOP DL10MS									;延时=BX值*10ms
        DEC BX
        JNZ DELAY										;延时=BX值*10ms
        MOV AL,AH										;恢复8255端口61H的原值原值
        OUT 61H,AL										;关闭扬声器
        POP DI										;恢复CPU现场
        POP DX							
        POP CX
        POP BX
        POP AX
        RET											;子程序结束返回
SOUND ENDP
;=========/*发送X Y*/========
SEND PROC NEAR										;查询方式发送X Y OVER
	PUSH AX										;保存CPU现场
	PUSH DX
LOOPX:
	MOV DX,0D409H
	IN AL,DX
	TEST AL,1
	JZ LOOPX
	MOV DX,0D408H
	MOV AL,X
	OUT DX,AL
LOOPW: 
    MOV DX,0D409H
    IN AL,DX
    TEST AL,1
    JZ LOOPW
    MOV DX,0D408H
    MOV AL,Y
    OUT DX,AL
	POP DX										;恢复CPU现场
	POP AX
	RET										;子程序结束返回
SEND ENDP
;/*发送我退出的消息*/
SENDQ PROC NEAR																															
	PUSH AX										;保存CPU现场
	PUSH DX
LOOY:
	MOV DX,0D409H
	IN AL,DX
	TEST AL,1
	JZ LOOY
	MOV DX,0D408H
	MOV AL,59									;我退出，发59(避开有效输入字符)
    OUT DX,AL
	POP DX										;恢复CPU现场
	POP AX
	RET										;子程序结束返回
SENDQ ENDP
;=========/*发送获胜消息*/========
SENDW PROC NEAR									;发送我退出的消息
	PUSH AX										;保存CPU现场
	PUSH DX
LOY:
	MOV DX,0D409H
	IN AL,DX
	TEST AL,1
	JZ LOY
	MOV DX,0D408H
	MOV AL,60									;我获胜，发60
    OUT DX,AL
	POP DX										;恢复CPU现场
	POP AX
	RET										;子程序结束返回
SENDW ENDP
;=========/*中断子程序*/========
IRQ11 PROC FAR					    
	PUSH AX										;保存CPU现场
	PUSH DX
    PUSH CX
	MOV DX,0D408H
	IN AL,DX
    CMP AL,59                           			
    JNZ L9											;若对方退出，将状态改为5
    MOV STATE,5										;对方退出
    CALL SLED										;数码管显示当前状态5
    JMP CLE										;清空棋盘
L9:    
    CMP AL,60
    jz hwin																				
    CMP STATE,1                         								;STATE=1表示我已下完，准备接收X
    JE XX											;准备接收x
    CMP STATE,2                        			 					;STATE=2表示准备接收Y
    JE YY											;准备接收y
    JMP CLE										;更新棋盘
XX: 											;接收X并将STATE=2
    MOV X,AL										;接收x的坐标
    MOV STATE,2
    JMP CLE										;在棋盘上显示坐标
YY:									
    MOV Y,AL										;接收y
    CMP ORDER,2										;该他下子
    JZ L7
    MOV MY,2										;我的坐标是2
    call check										;检查落子是否合法
    CALL PUTDOWN2									;双机落子
    CALL PRINT										;打印棋盘
    MOV MY,1										;我的坐标是1
    mov state,0										;游戏正在进行中
    call sled      										;数码管显示当前状态                                             
    JMP CLE										;棋盘屏幕更新
L7: 
    MOV MY,1										;我的坐标是1，对方的坐标是2
    call check										;检查落子是否合法
    CALL PUTDOWN2									;落子
    CALL PRINT										;打印棋盘
    MOV MY,2										;我的坐标是2，对方坐标是1
    mov state,0										;该我落子
    call sled   										;数码管显示当前状态                                                 
    JMP CLE										;屏幕棋盘更新
HWIN:											;如果他赢了，STATE=4
    MOV STATE,4										;对方赢了
    CALL SLED    										;数码管显示当前状态                                                  
    JMP CLE										;清空棋盘
CLE:
	MOV AL,20H									;清除PCI9052中断标志
	OUT 20H,AL
    mov al,20h
    out 0a0h,al 
	MOV DX,0D84DH
	MOV AL,1DH
	OUT DX,AL									;清9052中断标志
    POP CX
	POP DX										;恢复CPU现场
	POP AX
	IRET										;中断返回
IRQ11 ENDP
CODE ENDS
	END START		 